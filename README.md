# puzzlehunt-svc-neo4j

**Tl;dr:** Two Java devs set out to learn about Neo4j and GraphQL. This repo is the result. 

In the summer of 2020, we set out to get a bit of practical experience with Neo4j and GraphQL by writing an API for a fictional app that supports players competing in a [puzzlehunt](https://en.wikipedia.org/wiki/Puzzlehunt) (*Ã  la* [DASH](http://playdash.org/), which uses the [ClueKeeper](https://www.cluekeeper.com/) app). 

The API's job is to provide CRUD operations for entities in the (simplified) puzzlehunt, the entities being:

- Hunts
- Leaderboards (ranked teams and their times)
- Teams
- Players
- Puzzles
- Hints
- Partial solutions (which let a team know whether they are on the right track to solving a puzzle)

We imagined the following data model for these entities:

```
Hunt
----
name: string
start: date
end: date
puzzles: Puzzle[] (ordered)
teams: Team[]

Leaderboard
-----------
teamResults: TeamResult[]

TeamResult
----------
name: string (team name)
finished: boolean
score: int
time: duration

Team
----
name: string
captain: Person
players: Person[]
progress: HuntProgress (this ends up being stored on team->puzzle relationships)

Person
------
name: String

Puzzle
------
name: string
hints: Hint[] (ordered)
answer: string
partialSolution: PartialSolution[]
par: int
points: int

Hint
----
text: text (or string? Does Neo make a distinction?)
unlockMins: int
cost: int

PartialSolution
---------------
guess: string
response: string
```

We also imagined some operations to perform on these entities, including:

- Get the leaderboard for a hunt
- Get all teams including their captains and players
- Update a team's roster, including moving a player from one team to another

# Goals and non-goals

What we were trying to accomplish:

  - Gain "level 1"  experience with Neo4j, GraphQL, and Java's support for those two things.
  - Develop "level 1" answers to the questions "what are graph databases good for, and under what circumstances should you consider using one?"
  - Develop "level 1" answers to the questions "what is GraphQL good for, and under what circumstances should you consider using it?"
  - Side goal: Learn about the Java module system and its value to a multi-module project like this one.

Non-goals:

  - Production readiness. This was very much a lab experiment, with no pretense of shippability.

Baises:

  - We're Java devs, so we tried to make things work in Java.
  - We focused on solving an OLTP/realtime problem rather than an analytical/batch one.

# A word about project structure

The puzzlehunt-svc-neo4j-app module contains the main runnable application which includes all the sub-modules where we tried experiments with different implementation approaches.

The puzzlehunt-svc-neo4j-app-graphql-java module is a second runnable application that you probably shouldn't be too interested in - the more substantial GraphQL experiments are still part of the puzzlehunt-svc-neo4j-app module. More details below.

# What we tried

The core of this project is a Neo4j database that was loaded with our puzzle-hunt schema represented by the load-data.cypher and add-constraints.cypher scripts. All the experiments used this database as their backend and demonstrate different ways to get data in and out of it.

##### 1st experiment: Spring MVC APIs with DAOs that use the Neo4j Java driver
This first and most basic experiment is in the puzzlehunt-svc-neo4j-driver module. This module contains Spring controllers prefixed with /driver, some simple POJO objects to define our entities, and DAO objects that run Cypher queries to perform queries and make updates. 

##### 2st experiment: Spring MVC APIs with Neo4j OGM
This experiment is in the puzzlehunt-svc-neo4j-ogm module and has endpoints prefixed with /ogm. The idea was to try Neo4j's OGM module as the implementation of our DAOs. We didn't do much with this experiment because Spring Data also uses OGM and seemed like it was going to add some functionality to make it more fun to work with, so we jumped ahead after writing just one proof-of-concept OGM example.

##### 3rd experiment: Spring MVC APIs with Neo4j OGM and Spring Data
This experiment is in the puzzlehunt-svc-neo4j-springdata module and has endpoints prefixed with /springdata. This experiment has a full OGM-annotated model for our database and a few example controllers. The TeamsController in particular got a lot of attention as an example of how REST APIs for this data model might really be built.

##### 4th experiment: GraphQL API with autogenerated queries 
This experiment is in the puzzlehunt-svc-neo4j-graphql module and its only endpoint is the GraphQL API at /graphql. This started as an experiment where we used the neo4j-graphql-java library to transform GraphQL queries and mutations into Cypher queries, execute them, and return the result. It evolved into an integration with the graphql-java library where these autogenerated Cypher queries are the implementation of each top-level query/mutation in our GraphQL schema, but where custom DataFetchers can still be plugged in for specific properties when needed.

This experiment also includes support for the graphiql client, which can be accessed at /graphiql.

# What we concluded

TODO: GraphQL + Neo4j + autogeneration of a single Cipher query for each request + optional overriding of property fetching = seems like a powerful solution that covers a lot of bases

# Learnings about libraries

TODO: What each of the various neo-graphql-java-spring-nani libraries are useful for

# Musings on Neo4j

TODO

# Musings on GraphQL

TODO

# Helpful resources

TODO: Links to particularly useful docs/resources

# Things to do next

## Improvements to make

- TODO: Features to implement to learn how they could be made to work/what power they add to the solution
- TODO: Code to clean up
- TODO: Tests to add
- TODO: Docs to write

## Research avenues to explore

### GRANDstack

- TODO: GRANDstack (pure - no Java)
- TODO: Subscriptions
- TODO: Caching
- TODO: Large data set vs query performance
