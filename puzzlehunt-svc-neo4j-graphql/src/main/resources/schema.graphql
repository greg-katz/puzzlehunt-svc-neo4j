type Query {
}

type Hunt {
  id: ID!
  name: String!
  start: String!  # TODO: Can start and end be of a custom Date scalar type that we define?
  end: String!
  puzzles: [Puzzle!]! @relation(name: "HAS")
  teams: [Team!]! @relation(name: "PLAYED", direction: IN)
  # IMPORTANT: The neo4j-graphql library has a particular expectation that the return value of these cypher queries be
  # a single column, which is why instead of returning multiple values this query takes pains to return just one value
  # that is an object whose properties are the desired return values.
  leaderboard: [TeamResult] @cypher(statement: """
    match (hunt:Hunt)<-[played:PLAYED]-(team:Team)-[solved:SOLVED]->(puzzle:Puzzle)
    with hunt.name as huntName, team, solved
    where huntName = this.name
    call {
      with huntName
      match (hunt:Hunt)-[:HAS]->(puzzle:Puzzle)
      where hunt.name = huntName
      return count(puzzle) as totalPuzzles
    }
    return {
      name: team.name,
      finished: count(solved.end) = totalPuzzles,
      score: sum(solved.points),
      time: sum(duration.between(solved.start, solved.end))
    } as teamResult
    order by teamResult.score
    """)
}

# There is something pretty magic going on here. The TeamResult is a "made up" object in that it is not an actual
# database entity, but it is put together from queries to other entities that come togethre in the leaderboard query
# above. The contrived "lunchLocation" field of the TeamResult shows that "made up" objects like this don't need to be
# flat - they can include made-up subobjects of their own. When the leaderboard is fetched the lunchLocation query
# is added automatically to the leaderboard query in order to fill out the TeamResult's lunchLocation field.

# TODO: TeamResult and LunchLocation are types that don't represent entities - it would be neat if we could prevent the
# neo4j-graphql SchemaBuilder from creating all of the normal derived queries and mutations for these because it doesn't
# make any sense to have them.
type TeamResult {
  name: String!
  finished: Boolean!
  score: Int!
  time: String!
  lunchLocation: LunchLocation! @cypher(statement: """
    RETURN {
    teamName: this.name,
    location: "Taco Del Mar"
    }
    """)
}

type LunchLocation {
  teamName: String!
  location: String!
}

type Puzzle {
  id: ID!
  name: String!
  answer: String!
  par: Int!
  points: Int!
  hints: [Hint!]! @relation(name: "HAS")
  partialSolutions: [PartialSolution!]! @relation(name: "HAS")
}

type Hint {
  id: ID!
  text: String!
  cost: Int!
  unlockMins: Int!
}

type PartialSolution {
  id: ID!
  solution: String!
  response: String!
}

type Team {
  id: ID!
  name: String!
  captain: Person! @relation(name: "CAPTAIN_OF", direction: IN)
  players: [Person!]! @relation(name: "MEMBER_OF", direction: IN)
}

type Person {
  id: ID!
  name: String!
}

type Mutation {
  SwitchTeams(playerId: ID!, fromTeamId: ID!, toTeamId: ID!): Team @cypher(statement: """
    MATCH (player:Person{id:$playerId})-[r:MEMBER_OF]-(fromTeam:Team{id:$fromTeamId})
    DELETE r
    WITH player
    MATCH (toTeam:Team{id:$toTeamId})
    CREATE (player)-[:MEMBER_OF]->(toTeam)
    RETURN toTeam as team
    """
  )
}