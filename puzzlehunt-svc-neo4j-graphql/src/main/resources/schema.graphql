type Query {
}

type Hunt {
  id: ID!
  name: String!
  start: String!  # TODO: Can start and end be of a custom Date scalar type that we define?
  end: String!
  puzzles: [Puzzle!]! @relation(name: "HAS")
  teams: [Team!]! @relation(name: "PLAYED", direction: IN)
  leaderboard: [TeamResult] @cypher(statement: """
    match (hunt:Hunt)<-[played:PLAYED]-(team:Team)-[solved:SOLVED]->(puzzle:Puzzle)
    with hunt.name as huntName, team, solved
    where huntName = this.name
    call {
      with huntName
      match (hunt:Hunt)-[:HAS]->(puzzle:Puzzle)
      where hunt.name = huntName
      return count(puzzle) as totalPuzzles
    }
    return {
      name: team.name,
      finished: count(solved.end) = totalPuzzles,
      score: sum(solved.points),
      time: sum(duration.between(solved.start, solved.end))
    } as teamResult
    order by teamResult.score
  """)
}

type TeamResult {
  name: String!
  finished: Boolean!
  score: Int!
  time: String!
  lunchLocation: LunchLocation! @cypher(statement: """
  RETURN {
  teamName: this.name,
  location: "Taco Del Mar"
  }""")
}

type LunchLocation {
  teamName: String!
  location: String!
}

type Puzzle {
  id: ID!
  name: String!
  answer: String!
  par: Int!
  points: Int!
  hints: [Hint!]! @relation(name: "HAS")
  partialSolutions: [PartialSolution!]! @relation(name: "HAS")
}

type Hint {
  id: ID!
  text: String!
  cost: Int!
  unlockMins: Int!
}

type PartialSolution {
  id: ID!
  solution: String!
  response: String!
}

type Team {
  id: ID!
  name: String!
  captain: Person! @relation(name: "CAPTAIN_OF", direction: IN)
  players: [Person!]! @relation(name: "MEMBER_OF", direction: IN)
}

type Person {
  id: ID!
  name: String!
}

type Mutation {
  SwitchTeams(playerId: ID!, fromTeamId: ID!, toTeamId: ID!): Team @cypher(statement:"""
    MATCH (player:Person{id:$playerId})-[r:MEMBER_OF]-(fromTeam:Team{id:$fromTeamId})
    DELETE r
    WITH player
    MATCH (toTeam:Team{id:$toTeamId})
    CREATE (player)-[:MEMBER_OF]->(toTeam)
    RETURN toTeam as team
    """
  )
}